\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k+kn}{import} \PYG{n}{Counter}
\PYG{k+kn}{from} \PYG{n+nn}{bitarray} \PYG{k+kn}{import} \PYG{n}{bitarray}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{entropy} \PYG{k+kn}{import} \PYG{n}{InfoTheory}

\PYG{n}{INPUT\PYGZus{}PATH} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}Alice29.txt\PYGZsq{}}
\PYG{n}{COMPRESSED\PYGZus{}PATH} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}compressed\PYGZsq{}}
\PYG{n}{DECOMPRESSED\PYGZus{}PATH} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}decompressed.txt\PYGZsq{}}
\PYG{n}{CODE\PYGZus{}TABLE\PYGZus{}PATH} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}code\PYGZus{}table.csv\PYGZsq{}}
\PYG{n}{OCCURANCE\PYGZus{}PATH} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}occurance.csv\PYGZsq{}}

\PYG{k}{class} \PYG{n+nc}{Node}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{):}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{zero}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{one}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{):}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{zero} \PYG{o}{=} \PYG{n}{zero}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{one} \PYG{o}{=} \PYG{n}{one}

    \PYG{k}{def} \PYG{n+nf}{children}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
        \PYG{k}{return} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{zero}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{one}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
        \PYG{k}{return} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{zero}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{one}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{read\PYGZus{}data}\PYG{p}{(}\PYG{n}{path}\PYG{p}{):}
    \PYG{c+c1}{\PYGZsh{} Output:}
    \PYG{c+c1}{\PYGZsh{}   data: file as array of raw bytes}
    \PYG{k}{if} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,} \PYG{n+nb}{str}\PYG{p}{):}
        \PYG{n}{data} \PYG{o}{=} \PYG{p}{[]}
        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}rb\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{byte} \PYG{o+ow}{in} \PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{():}
                \PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{byte}\PYG{o}{.}\PYG{n}{to\PYGZus{}bytes}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{byteorder}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}big\PYGZsq{}}\PYG{p}{))}
        \PYG{k}{return} \PYG{n}{data}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{TypeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Input must be a string\PYGZsq{}}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}to\PYGZus{}file}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{path}\PYG{p}{):}
    \PYG{c+c1}{\PYGZsh{} Input:}
    \PYG{c+c1}{\PYGZsh{}   data: bytes to print}
    \PYG{c+c1}{\PYGZsh{}   path: string with the path to the file}
    \PYG{c+c1}{\PYGZsh{} print(type(data))}
    \PYG{c+c1}{\PYGZsh{} print(type(path))}
    \PYG{k}{if} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n+nb}{bytes}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,} \PYG{n+nb}{str}\PYG{p}{):}
        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}wb\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{TypeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Input must be bytes and a string\PYGZsq{}}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{huffman\PYGZus{}tree}\PYG{p}{(}\PYG{n}{occurrences}\PYG{p}{):}
    \PYG{c+c1}{\PYGZsh{} Input:}
    \PYG{c+c1}{\PYGZsh{}  occurrences: dictionary with the number of occurrences of each symbol}
    \PYG{c+c1}{\PYGZsh{} Output:}
    \PYG{c+c1}{\PYGZsh{}   root: the root of the Huffman tree}
    \PYG{k}{if} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{occurrences}\PYG{p}{,} \PYG{n+nb}{dict}\PYG{p}{):}
        \PYG{n}{probabilities} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{([(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}
                                \PYG{k}{for} \PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{occurrences}\PYG{o}{.}\PYG{n}{items}\PYG{p}{()],} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{])}
        \PYG{k}{while} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{probabilities}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{n}{left} \PYG{o}{=} \PYG{n}{probabilities}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{n}{right} \PYG{o}{=} \PYG{n}{probabilities}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{n}{node} \PYG{o}{=} \PYG{n}{Node}\PYG{p}{(}\PYG{n}{left}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{],} \PYG{n}{right}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{])}
            \PYG{n}{probabilities}\PYG{o}{.}\PYG{n}{append}\PYG{p}{((}\PYG{n}{node}\PYG{p}{,} \PYG{n}{left}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{right}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]))}
            \PYG{n}{probabilities} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{probabilities}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{])}
        \PYG{k}{return} \PYG{n}{probabilities}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{TypeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Input must be a dictionary\PYGZsq{}}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{codebook}\PYG{p}{(}\PYG{n}{node}\PYG{p}{,} \PYG{n}{code}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{p}{):}
    \PYG{c+c1}{\PYGZsh{} Input:}
    \PYG{c+c1}{\PYGZsh{}   root: the root of the Huffman tree}
    \PYG{c+c1}{\PYGZsh{}   code: the code for the current node}
    \PYG{c+c1}{\PYGZsh{} Output:}
    \PYG{c+c1}{\PYGZsh{}   codebook: a dictionary with the Huffman code for each symbol}
    \PYG{k}{if} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{node}\PYG{p}{,} \PYG{n}{Node}\PYG{p}{):}
        \PYG{n}{book} \PYG{o}{=} \PYG{p}{\PYGZob{}\PYGZcb{}}
        \PYG{p}{(}\PYG{n}{zero}\PYG{p}{,} \PYG{n}{one}\PYG{p}{)} \PYG{o}{=} \PYG{n}{node}\PYG{o}{.}\PYG{n}{children}\PYG{p}{()}
        \PYG{n}{book}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{codebook}\PYG{p}{(}\PYG{n}{zero}\PYG{p}{,} \PYG{n}{code}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{))}
        \PYG{n}{book}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{codebook}\PYG{p}{(}\PYG{n}{one}\PYG{p}{,} \PYG{n}{code}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{))}
        \PYG{k}{return} \PYG{n}{book}
    \PYG{k}{elif} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{node}\PYG{p}{,} \PYG{n+nb}{bytes}\PYG{p}{):}
        \PYG{k}{return} \PYG{p}{\PYGZob{}}\PYG{n}{node}\PYG{p}{:} \PYG{n}{code}\PYG{p}{\PYGZcb{}}
    \PYG{k}{elif} \PYG{n}{node} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{\PYGZob{}\PYGZcb{}}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{node}\PYG{p}{))}
        \PYG{k}{raise} \PYG{n+ne}{TypeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Input must be a Node\PYGZsq{}}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{compress}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{codebook}\PYG{p}{):}
    \PYG{c+c1}{\PYGZsh{} Input:}
    \PYG{c+c1}{\PYGZsh{}   data: list of bytes with the data to compress}
    \PYG{c+c1}{\PYGZsh{}   codebook: a dictionary with the Huffman code for each byte}
    \PYG{c+c1}{\PYGZsh{} Output:}
    \PYG{c+c1}{\PYGZsh{}   compressed\PYGZus{}data: bytes with the compressed data}
    \PYG{k}{if} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{codebook}\PYG{p}{,} \PYG{n+nb}{dict}\PYG{p}{):}
        \PYG{n}{s} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}
        \PYG{k}{for} \PYG{n}{symbol} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{:}
            \PYG{n}{s} \PYG{o}{+=} \PYG{p}{(}\PYG{n}{codebook}\PYG{p}{[}\PYG{n}{symbol}\PYG{p}{])}

        \PYG{c+c1}{\PYGZsh{} If the compressed data is not a multiple of 8, it will add dummy bits to make it a multiple of 8}
        \PYG{c+c1}{\PYGZsh{} Select dummy bits so that they match no code in the codebook}
        \PYG{c+c1}{\PYGZsh{} If it doesn\PYGZsq{}t find any unused bit combination in 2\PYGZca{}l attempts, it will simply fill it with zeroes which might add additional characters on decompression}
        \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{8} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{l} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{8}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{8}\PYG{p}{)}
            \PYG{n}{inv\PYGZus{}codebook} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{value}\PYG{p}{:} \PYG{n}{key} \PYG{k}{for} \PYG{n}{key}\PYG{p}{,} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{codebook}\PYG{o}{.}\PYG{n}{items}\PYG{p}{()\PYGZcb{}}
            \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{pow}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{l}\PYG{p}{)):}
                \PYG{n}{dummy\PYGZus{}bits} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{element}\PYG{p}{)} \PYG{k}{for} \PYG{n}{element} \PYG{o+ow}{in} \PYG{p}{[}
                                     \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{([}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{])} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)])}
                \PYG{k}{if} \PYG{n+nb}{any}\PYG{p}{([}\PYG{n}{inv\PYGZus{}codebook}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{dummy\PYGZus{}bits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{i}\PYG{p}{])} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dummy\PYGZus{}bits}\PYG{p}{))]):}
                    \PYG{k}{continue}
                \PYG{k}{else}\PYG{p}{:}
                    \PYG{n}{s} \PYG{o}{+=} \PYG{n}{dummy\PYGZus{}bits}
                    \PYG{k}{break}
        \PYG{n}{compressed\PYGZus{}data} \PYG{o}{=} \PYG{n}{bitarray}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{.}\PYG{n}{tobytes}\PYG{p}{()}
        \PYG{k}{return} \PYG{n}{compressed\PYGZus{}data}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{TypeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Input must be a list and a dictionary\PYGZsq{}}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{decompress}\PYG{p}{(}\PYG{n}{compressed\PYGZus{}data}\PYG{p}{,} \PYG{n}{codebook}\PYG{p}{):}
    \PYG{c+c1}{\PYGZsh{} Input:}
    \PYG{c+c1}{\PYGZsh{}   compressed\PYGZus{}data: list of bytes with the data to decompress}
    \PYG{c+c1}{\PYGZsh{}   codebook: a dictionary with the Huffman code for each byte}
    \PYG{c+c1}{\PYGZsh{} Output:}
    \PYG{c+c1}{\PYGZsh{}   data: bytes with the decompressed data}
    \PYG{k}{if} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{compressed\PYGZus{}data}\PYG{p}{,} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{codebook}\PYG{p}{,} \PYG{n+nb}{dict}\PYG{p}{):}
        \PYG{n}{data} \PYG{o}{=} \PYG{n+nb}{bytes}\PYG{p}{()}
        \PYG{n}{codebook} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{value}\PYG{p}{:} \PYG{n}{key} \PYG{k}{for} \PYG{n}{key}\PYG{p}{,} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{codebook}\PYG{o}{.}\PYG{n}{items}\PYG{p}{()\PYGZcb{}}
        \PYG{n}{compressed\PYGZus{}data} \PYG{o}{=} \PYG{l+s+sa}{b}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{compressed\PYGZus{}data}\PYG{p}{)}
        \PYG{n}{s} \PYG{o}{=} \PYG{n}{bitarray}\PYG{p}{()}
        \PYG{n}{s}\PYG{o}{.}\PYG{n}{frombytes}\PYG{p}{(}\PYG{n}{compressed\PYGZus{}data}\PYG{p}{)}
        \PYG{n}{s} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{to01}\PYG{p}{()}
        \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{):}
            \PYG{n}{j} \PYG{o}{=} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}
            \PYG{k}{while} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{:}\PYG{n}{j}\PYG{p}{]} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{codebook}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{()} \PYG{o+ow}{and} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{):}
                \PYG{n}{j} \PYG{o}{+=} \PYG{l+m+mi}{1}
            \PYG{k}{if} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}
                \PYG{n}{data} \PYG{o}{+=} \PYG{p}{(}\PYG{n}{codebook}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{:}\PYG{n}{j}\PYG{p}{]])}
            \PYG{k}{elif} \PYG{n}{j} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{:}\PYG{n}{j}\PYG{p}{]} \PYG{o+ow}{in} \PYG{n}{codebook}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{():}
                \PYG{n}{data} \PYG{o}{+=} \PYG{p}{(}\PYG{n}{codebook}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{:}\PYG{n}{j}\PYG{p}{]])}
            \PYG{n}{i} \PYG{o}{=} \PYG{n}{j}
        \PYG{k}{return} \PYG{n}{data}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{TypeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Input must be a list and a dictionary\PYGZsq{}}\PYG{p}{)}
    
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}codebook}\PYG{p}{(}\PYG{n}{codebook}\PYG{p}{,} \PYG{n}{occurrences}\PYG{p}{):}
    \PYG{c+c1}{\PYGZsh{} Input:}
    \PYG{c+c1}{\PYGZsh{}   codebook: a dictionary with the Huffman code for each byte}
    \PYG{c+c1}{\PYGZsh{} Output:}
    \PYG{c+c1}{\PYGZsh{}   code\PYGZus{}table.csv: a csv file with the codebook}
    \PYG{k}{if} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{codebook}\PYG{p}{,} \PYG{n+nb}{dict}\PYG{p}{):}
        \PYG{n}{probabilities} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{([(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}
            \PYG{k}{for} \PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{occurrences}\PYG{o}{.}\PYG{n}{items}\PYG{p}{()],} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{],} \PYG{n}{reverse}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{CODE\PYGZus{}TABLE\PYGZus{}PATH}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}w\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}symbol,probability,code}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{for} \PYG{p}{[}\PYG{n}{key}\PYG{p}{,} \PYG{n}{value}\PYG{p}{]} \PYG{o+ow}{in} \PYG{n}{probabilities}\PYG{p}{:}
                \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{,}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{,}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{key}\PYG{o}{.}\PYG{n}{hex}\PYG{p}{(),} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{value}\PYG{p}{),} \PYG{n}{codebook}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]))}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{TypeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Input must be a dictionary\PYGZsq{}}\PYG{p}{)}
    
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}occurance}\PYG{p}{(}\PYG{n}{occurrences}\PYG{p}{):}
    \PYG{c+c1}{\PYGZsh{} Input:}
    \PYG{c+c1}{\PYGZsh{}   codebook: a dictionary with the Huffman code for each byte}
    \PYG{c+c1}{\PYGZsh{} Output:}
    \PYG{c+c1}{\PYGZsh{}   code\PYGZus{}table.csv: a csv file with the codebook}
    \PYG{k}{if} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{codebook}\PYG{p}{,} \PYG{n+nb}{dict}\PYG{p}{):}
        \PYG{n}{probabilities} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{([(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}
            \PYG{k}{for} \PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{occurrences}\PYG{o}{.}\PYG{n}{items}\PYG{p}{()],} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{],} \PYG{n}{reverse}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{OCCURANCE\PYGZus{}PATH}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}w\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}symbol,probability}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{for} \PYG{p}{[}\PYG{n}{key}\PYG{p}{,} \PYG{n}{value}\PYG{p}{]} \PYG{o+ow}{in} \PYG{n}{probabilities}\PYG{p}{:}
                \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{,}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{key}\PYG{o}{.}\PYG{n}{hex}\PYG{p}{(),} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)))}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{TypeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Input must be a dictionary\PYGZsq{}}\PYG{p}{)}



\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}\PYGZsq{}}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} COMPRESS}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{read\PYGZus{}data}\PYG{p}{(}\PYG{n}{INPUT\PYGZus{}PATH}\PYG{p}{)}
    \PYG{n}{occurrences} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
    \PYG{n}{root} \PYG{o}{=} \PYG{n}{huffman\PYGZus{}tree}\PYG{p}{(}\PYG{n}{occurrences}\PYG{p}{)}
    \PYG{n}{codebook} \PYG{o}{=} \PYG{n}{codebook}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
    \PYG{n}{compressed\PYGZus{}data} \PYG{o}{=} \PYG{n}{compress}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{codebook}\PYG{p}{)}

    \PYG{n}{entropy} \PYG{o}{=} \PYG{n}{InfoTheory}\PYG{o}{.}\PYG{n}{Entropy}\PYG{p}{(}\PYG{n}{InfoTheory}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{([}\PYG{n}{value}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{occurrences}\PYG{o}{.}\PYG{n}{items}\PYG{p}{()]))}
    \PYG{n}{entropy\PYGZus{}compressed} \PYG{o}{=} \PYG{n}{InfoTheory}\PYG{o}{.}\PYG{n}{Entropy}\PYG{p}{(}\PYG{n}{InfoTheory}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{([}\PYG{n}{value}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{Counter}\PYG{p}{(}\PYG{n}{compressed\PYGZus{}data}\PYG{p}{)}\PYG{o}{.}\PYG{n}{items}\PYG{p}{()]))}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Entropy of original text: \PYGZdq{}} \PYG{o}{+} \PYG{n}{entropy}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Entropy of compressed text: \PYGZdq{}} \PYG{o}{+} \PYG{n}{entropy\PYGZus{}compressed}\PYG{p}{)}

    \PYG{n}{average\PYGZus{}length} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{([}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{codebook}\PYG{p}{[}\PYG{n}{key}\PYG{p}{])}\PYG{o}{*}\PYG{n}{value} \PYG{k}{for} \PYG{n}{key}\PYG{p}{,} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{occurrences}\PYG{o}{.}\PYG{n}{items}\PYG{p}{()])}\PYG{o}{/}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Average character length in compressed text: \PYGZdq{}} \PYG{o}{+} \PYG{n}{average\PYGZus{}length}\PYG{p}{)}

    \PYG{n}{print\PYGZus{}to\PYGZus{}file}\PYG{p}{(}\PYG{n}{compressed\PYGZus{}data}\PYG{p}{,} \PYG{n}{COMPRESSED\PYGZus{}PATH}\PYG{p}{)}
    \PYG{n}{print\PYGZus{}codebook}\PYG{p}{(}\PYG{n}{codebook}\PYG{p}{,} \PYG{n}{occurrences}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} DECOMPRESS}
    \PYG{n}{compressed} \PYG{o}{=} \PYG{n}{read\PYGZus{}data}\PYG{p}{(}\PYG{n}{COMPRESSED\PYGZus{}PATH}\PYG{p}{)}
    \PYG{n}{comp\PYGZus{}count} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{n}{compressed}\PYG{p}{)}
    \PYG{n}{print\PYGZus{}occurance}\PYG{p}{(}\PYG{n}{comp\PYGZus{}count}\PYG{p}{)}
    \PYG{n}{decompressed} \PYG{o}{=} \PYG{n}{decompress}\PYG{p}{(}\PYG{n}{compressed}\PYG{p}{,} \PYG{n}{codebook}\PYG{p}{)}
    \PYG{n}{print\PYGZus{}to\PYGZus{}file}\PYG{p}{(}\PYG{n}{decompressed}\PYG{p}{,} \PYG{n}{DECOMPRESSED\PYGZus{}PATH}\PYG{p}{)}
\end{Verbatim}
